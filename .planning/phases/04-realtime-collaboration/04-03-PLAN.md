---
phase: 04-realtime-collaboration
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - src/app/core/services/realtime.service.ts
  - src/app/features/dishes/dishes.component.ts
  - src/app/features/meal-plan/meal-plan.component.ts
  - src/app/features/settings/components/activity-feed/activity-feed.component.ts
  - src/app/features/settings/components/activity-feed/activity-feed.component.html
  - src/app/features/settings/settings.component.ts
  - src/app/features/settings/settings.component.html
  - src/app/shared/components/layout/layout.component.ts
autonomous: true
requirements: [UI-03, AUTH-06]

must_haves:
  truths:
    - "Changes by one household member to dishes appear instantly for other members without page refresh"
    - "Changes by one household member to meal assignments appear instantly for other members without page refresh"
    - "A subtle toast notification shows what changed and who changed it, using activity_log payload with display_name (e.g. 'Lisa hat Lachs hinzugefuegt')"
    - "Activity feed shows recent household changes with timestamps and user names"
    - "Realtime subscriptions are cleaned up when the user navigates away or logs out"
    - "Solo users (no household) are unaffected — no subscriptions, no toasts, no degradation"
  artifacts:
    - path: "src/app/core/services/realtime.service.ts"
      provides: "Singleton RealtimeService managing Supabase Realtime channel subscriptions per household"
      exports: ["RealtimeService"]
    - path: "src/app/features/settings/components/activity-feed/activity-feed.component.ts"
      provides: "ActivityFeedComponent displaying recent household activity log entries"
    - path: "src/app/features/settings/settings.component.html"
      provides: "Updated settings page with activity feed below household panel"
  key_links:
    - from: "src/app/core/services/realtime.service.ts"
      to: "src/app/core/services/supabase.service.ts"
      via: "inject(SupabaseService) for .client.channel()"
      pattern: "\\.channel\\("
    - from: "src/app/core/services/realtime.service.ts"
      to: "src/app/core/services/household.service.ts"
      via: "inject(HouseholdService) for householdId signal — subscribes only when household exists"
      pattern: "inject\\(HouseholdService\\)"
    - from: "src/app/features/dishes/dishes.component.ts"
      to: "src/app/core/services/realtime.service.ts"
      via: "subscribes to dish changes and reloads dish list"
      pattern: "inject\\(RealtimeService\\)"
    - from: "src/app/features/meal-plan/meal-plan.component.ts"
      to: "src/app/core/services/realtime.service.ts"
      via: "subscribes to meal_assignment changes and reloads week data"
      pattern: "inject\\(RealtimeService\\)"
    - from: "src/app/features/settings/components/activity-feed/activity-feed.component.ts"
      to: "src/app/core/services/realtime.service.ts"
      via: "inject(RealtimeService) — effect() watches dishChange/assignmentChange to refresh feed"
      pattern: "inject\\(RealtimeService\\)"
---

<objective>
Wire up Supabase Realtime subscriptions so household members see each other's changes instantly, with toast notifications and an activity feed.

Purpose: This is the core "collaboration" experience. Without Realtime, household members would need to manually refresh to see changes. With it, the app feels like a shared, live workspace — the final piece of the v1 vision.

Output:
- RealtimeService managing channel subscriptions per household
- DishesComponent and MealPlanComponent react to Realtime events (reload data + show toast)
- ActivityFeedComponent showing recent changes in settings page
- Clean subscription lifecycle (subscribe on household join, unsubscribe on leave/logout)
</objective>

<execution_context>
@C:/Users/simon/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/simon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-realtime-collaboration/04-CONTEXT.md
@.planning/phases/04-realtime-collaboration/04-RESEARCH.md
@.planning/phases/04-realtime-collaboration/04-01-SUMMARY.md
@.planning/phases/04-realtime-collaboration/04-02-SUMMARY.md
@src/app/core/services/supabase.service.ts
@src/app/core/services/household.service.ts
@src/app/features/dishes/dishes.component.ts
@src/app/features/meal-plan/meal-plan.component.ts
@src/app/features/settings/settings.component.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RealtimeService and integrate live updates into DishesComponent and MealPlanComponent</name>
  <files>
    src/app/core/services/realtime.service.ts
    src/app/features/dishes/dishes.component.ts
    src/app/features/meal-plan/meal-plan.component.ts
    src/app/shared/components/layout/layout.component.ts
  </files>
  <action>
**A. Create `src/app/core/services/realtime.service.ts`:**

Singleton service (`providedIn: 'root'`). Manages one Supabase Realtime channel per household.

**Dependencies:**
- `inject(SupabaseService)` — for `.client.channel()` and `.client.removeChannel()`
- `inject(HouseholdService)` — for `householdId` signal
- `inject(DestroyRef)` — for cleanup on service destroy

**Signals:**
- `dishChange = signal<{ eventType: string; new: any; old: any } | null>(null)` — emits on dishes postgres_changes
- `assignmentChange = signal<{ eventType: string; new: any; old: any } | null>(null)` — emits on meal_assignments postgres_changes
- `memberChange = signal<{ eventType: string; new: any; old: any } | null>(null)` — emits on household_members changes
- `activityChange = signal<{ eventType: string; new: any; old: any } | null>(null)` — emits on activity_log postgres_changes (INSERT). The `new` payload includes `display_name`, `action`, `entity_name` from the trigger-populated activity_log row. This is the source for person-named toast messages.

**Private state:**
- `private channel: RealtimeChannel | null = null`

**Methods:**

1. `subscribe(householdId: string): void` — Creates a single channel `household:${householdId}` with multiple `.on('postgres_changes', ...)` listeners:
   - `dishes` table, filtered by `household_id=eq.${householdId}`, event `*` (INSERT/UPDATE/DELETE). On event: set `dishChange` signal.
   - `meal_assignments` table, no filter (RLS handles security; meal_assignments don't have household_id directly). On event: set `assignmentChange` signal.
   - `household_members` table, filtered by `household_id=eq.${householdId}`, event `*`. On event: set `memberChange` signal.
   - `activity_log` table, filtered by `household_id=eq.${householdId}`, event `INSERT`. On event: set `activityChange` signal. The activity_log rows are populated by triggers (from 04-01 migration) and include `display_name`, `action`, `entity_name` — everything needed for person-named toasts.
   - Call `.subscribe()` on the channel.

2. `unsubscribe(): void` — If channel exists, call `this.supabase.client.removeChannel(this.channel)`, set channel to null. Reset all signals to null.

3. Constructor: Use `effect()` watching `householdService.householdId()`:
   - If householdId is not null and different from current subscription: unsubscribe old, subscribe new.
   - If householdId becomes null (left household, solo mode): unsubscribe.

4. `DestroyRef.onDestroy()`: call `unsubscribe()`.

**B. Update DishesComponent** (`src/app/features/dishes/dishes.component.ts`):

Add `private realtime = inject(RealtimeService)`.

In constructor, add two `effect()` calls:

**Effect 1 — Data reload** watching `this.realtime.dishChange()`:
```typescript
effect(() => {
  const change = this.realtime.dishChange();
  if (change) {
    // Reload the full dish list (simplest, avoids partial state bugs)
    this.loadDishes();
  }
});
```

**Effect 2 — Person-named toast** watching `this.realtime.activityChange()`:
```typescript
effect(() => {
  const activity = this.realtime.activityChange();
  if (activity && activity.new?.entity_type === 'dish') {
    // activity_log rows include display_name and entity_name from triggers (04-01 migration)
    const displayName = activity.new.display_name || 'Jemand';
    const entityName = activity.new.entity_name || 'Gericht';
    const action = activity.new.action;

    // Only show toast if change was made by someone else
    const currentUserId = this.currentUserId;
    if (activity.new.user_id !== currentUserId) {
      let message = '';
      switch (action) {
        case 'dish_added': message = `${displayName} hat ${entityName} hinzugefuegt`; break;
        case 'dish_updated': message = `${displayName} hat ${entityName} geaendert`; break;
        case 'dish_deleted': message = `${displayName} hat ${entityName} entfernt`; break;
      }
      if (message) {
        this.snackBar.open(message, '', { duration: 3000 });
      }
    }
  }
});
```

To get current user ID efficiently, add a `private currentUserId: string | null = null` and set it in `ngOnInit` from `this.supabase.client.auth.getUser()`.

**Why activityChange instead of dishChange for toasts:** Per user decision (CONTEXT.md), toasts must include the person's name ("Lisa hat Lachs hinzugefuegt"). The `postgres_changes` payload on `dishes` does not include the user's display name. The `activity_log` table is populated by triggers (04-01 migration) that look up `display_name` from profiles, so `activityChange` events arrive with `display_name`, `action`, and `entity_name` — everything needed for person-named toasts without extra lookups.

**C. Update MealPlanComponent** (`src/app/features/meal-plan/meal-plan.component.ts`):

Add `private realtime = inject(RealtimeService)`.

In constructor, add two `effect()` calls:

**Effect 1 — Data reload** watching `this.realtime.assignmentChange()`:
```typescript
effect(() => {
  const change = this.realtime.assignmentChange();
  if (change) {
    // Reload the current week's assignments
    this.loadWeek();
  }
});
```

**Effect 2 — Person-named toast** watching `this.realtime.activityChange()`:
```typescript
effect(() => {
  const activity = this.realtime.activityChange();
  if (activity && (activity.new?.entity_type === 'meal_assignment' || activity.new?.entity_type === 'weekly_plan')) {
    const displayName = activity.new.display_name || 'Jemand';
    const entityName = activity.new.entity_name || 'Wochenplan';
    const action = activity.new.action;

    const currentUserId = this.currentUserId;
    if (activity.new.user_id !== currentUserId) {
      let message = '';
      switch (action) {
        case 'assignment_changed': message = `${displayName} hat ${entityName} geaendert`; break;
        case 'plan_generated': message = `${displayName} hat Wochenplan generiert`; break;
        default: message = `${displayName} hat ${entityName} geaendert`; break;
      }
      if (message) {
        this.snackBar.open(message, '', { duration: 3000 });
      }
    }
  }
});
```

To get current user ID, add a `private currentUserId: string | null = null` and set it in `ngOnInit` from `this.supabase.client.auth.getUser()`.

**Important:** The `effect()` calls for Realtime must NOT conflict with the existing `effect()` that watches `currentWeekStart` for navigation. They are independent — one reacts to week changes, the other to external data changes. Both call `loadWeek()` which is safe to call multiple times (it replaces the signal value).

**D. Update LayoutComponent** (`src/app/shared/components/layout/layout.component.ts`):

**Note:** LayoutComponent already has invite-token sessionStorage logic from Plan 04-02 (inject(HouseholdService), inject(MatSnackBar), and the `sessionStorage.getItem('invite_token')` check in ngOnInit). This task only needs to add `inject(RealtimeService)` alongside the existing injects.

Add `private realtime = inject(RealtimeService)` — this ensures the RealtimeService is instantiated when the authenticated layout loads (since it's providedIn: 'root', it's lazy; injecting it in LayoutComponent guarantees it starts). The service's internal `effect()` on `householdId` handles subscribe/unsubscribe automatically. No other changes to LayoutComponent are needed.
  </action>
  <verify>
    - `src/app/core/services/realtime.service.ts` exists and exports RealtimeService
    - RealtimeService has `dishChange`, `assignmentChange`, `memberChange`, `activityChange` signals
    - RealtimeService has `subscribe(householdId)` and `unsubscribe()` methods
    - RealtimeService uses `effect()` on `householdService.householdId()` for auto-subscribe
    - RealtimeService calls `removeChannel()` in DestroyRef cleanup
    - DishesComponent injects RealtimeService and has `effect()` watching `dishChange`
    - DishesComponent shows person-named snackbar toast via `activityChange` on external dish changes (e.g. "Lisa hat Lachs hinzugefuegt")
    - MealPlanComponent injects RealtimeService and has `effect()` watching `assignmentChange`
    - MealPlanComponent shows person-named snackbar toast via `activityChange` on external assignment changes (e.g. "Max hat Montag geaendert")
    - LayoutComponent injects RealtimeService to ensure initialization
    - `ng build` compiles without errors
  </verify>
  <done>
    RealtimeService subscribes to household Realtime channel automatically when householdId signal is set. DishesComponent and MealPlanComponent reload their data and show toast notifications when external changes arrive. Subscriptions are cleaned up on household leave, logout, or service destroy. Solo users have no subscriptions and no performance impact.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create activity feed component and integrate into settings page</name>
  <files>
    src/app/features/settings/components/activity-feed/activity-feed.component.ts
    src/app/features/settings/components/activity-feed/activity-feed.component.html
    src/app/features/settings/settings.component.ts
    src/app/features/settings/settings.component.html
  </files>
  <action>
**A. Create ActivityFeedComponent** (`src/app/features/settings/components/activity-feed/`):

Standalone component. Inject HouseholdService for `getActivityLog()`.

**State signals:**
- `entries = signal<ActivityLogEntry[]>([])`
- `isLoading = signal(true)`

**On init:**
- If household exists (check `householdService.currentHousehold()`), call `householdService.getActivityLog(30)` (last 30 entries).
- Set `entries` signal and `isLoading` to false.

**Template:**
German heading "Letzte Aktivitaeten".

If no household: don't render (component should not appear for solo users — parent controls this).

If loading: show "Laden..." text.

If no entries: show "Noch keine Aktivitaeten" muted text.

For each entry, show a row with:
- Icon based on `action`: dish_added = plate emoji, dish_deleted = X emoji, assignment_changed = calendar emoji, plan_generated = sparkle emoji, etc.
- Text: `${entry.display_name || 'Jemand'} hat ${actionText(entry)}` where `actionText` maps:
  - `dish_added` -> `"${entity_name} hinzugefuegt"`
  - `dish_updated` -> `"${entity_name} geaendert"`
  - `dish_deleted` -> `"${entity_name} entfernt"`
  - `assignment_changed` -> `"${entity_name} geaendert"` (entity_name = day name like "Montag")
  - `plan_generated` -> `"Wochenplan generiert"`
  - default -> `"etwas geaendert"`
- Relative timestamp: "vor 2 Min.", "vor 1 Std.", "Gestern", etc. Write a simple `timeAgo(dateString: string): string` pipe or method.

**Styling:**
- Compact list layout, no cards per entry (simple divider lines)
- Muted text color for timestamps
- Subtle left border accent per entry type (optional: green for adds, red for deletes, blue for updates)
- Max height with overflow-y-auto for scrolling if many entries

**B. Update SettingsComponent:**

Import and render ActivityFeedComponent below HouseholdPanelComponent, but only when user has a household:

```html
<div class="p-4 max-w-4xl mx-auto">
  <h1 class="text-2xl font-bold text-gray-800 mb-6">Einstellungen</h1>
  <app-household-panel />
  @if (hasHousehold()) {
    <div class="mt-6">
      <app-activity-feed />
    </div>
  }
</div>
```

Add `hasHousehold` computed signal: `hasHousehold = computed(() => this.householdService.currentHousehold() !== null)`. Inject HouseholdService.

**C. Realtime refresh of activity feed:**

Add a `private realtime = inject(RealtimeService)` to ActivityFeedComponent. Use `effect()` watching any of the change signals:

```typescript
effect(() => {
  // Re-fetch activity log whenever a dish or assignment change occurs
  const dc = this.realtime.dishChange();
  const ac = this.realtime.assignmentChange();
  if (dc || ac) {
    this.loadActivity();
  }
});
```

This keeps the activity feed live — when a household member makes a change, the trigger writes to activity_log, and the Realtime event causes a re-fetch.
  </action>
  <verify>
    - `src/app/features/settings/components/activity-feed/activity-feed.component.ts` exists
    - ActivityFeedComponent imports HouseholdService and RealtimeService
    - ActivityFeedComponent has `entries` signal populated from `getActivityLog()`
    - Template shows German action descriptions ("hat X hinzugefuegt")
    - Template shows relative timestamps
    - SettingsComponent imports ActivityFeedComponent
    - SettingsComponent template conditionally renders activity feed when household exists
    - `ng build` compiles without errors
  </verify>
  <done>
    Activity feed displays recent household changes with user names, action descriptions in German, and relative timestamps. Feed auto-refreshes via Realtime signals when new changes arrive. Only visible when user belongs to a household; solo users see no activity feed.
  </done>
</task>

</tasks>

<verification>
- Open two browser tabs with different household members logged in
- In tab 1: add a new dish. Tab 2 should show the dish appear without refresh and show a toast
- In tab 1: assign a dish to a day in Wochenplan. Tab 2 should show the update without refresh
- Activity feed on /einstellungen shows the recent changes with correct German text
- Logging out or leaving household removes Realtime subscriptions (no WebSocket leaks)
- Solo user (no household) has no subscriptions and sees no toasts
- `ng build` passes with zero errors
</verification>

<success_criteria>
- Realtime changes propagate instantly between household members
- Toast notifications display on external changes
- Activity feed shows recent household activity with timestamps
- Subscriptions are properly managed (subscribe on join, unsubscribe on leave/destroy)
- Solo mode unchanged — no performance impact for non-household users
</success_criteria>

<output>
After completion, create `.planning/phases/04-realtime-collaboration/04-03-SUMMARY.md`
</output>
