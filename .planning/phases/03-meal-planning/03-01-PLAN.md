---
phase: 03-meal-planning
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/003_meal_plans.sql
  - src/app/features/meal-plan/models/meal-plan.model.ts
  - src/app/features/meal-plan/services/meal-plan.service.ts
autonomous: true
requirements: [PLAN-01, PLAN-02, PLAN-05]
must_haves:
  truths:
    - "Weekly plans and meal assignments can be persisted per user with RLS isolation"
    - "Category preferences can be stored and retrieved per user"
    - "MealPlanService can create, load, and update weekly plans with meal assignments"
    - "MealPlanService can query recent meal assignments for repeat avoidance"
    - "Category preference defaults are provided when user has no saved config"
  artifacts:
    - path: "supabase/migrations/003_meal_plans.sql"
      provides: "Database tables for weekly_plans, meal_assignments, category_preferences with RLS"
      contains: "CREATE TABLE public.weekly_plans"
    - path: "src/app/features/meal-plan/models/meal-plan.model.ts"
      provides: "TypeScript interfaces for WeeklyPlan, MealAssignment, CategoryPreference, DayOfWeek"
      exports: ["WeeklyPlan", "MealAssignment", "CategoryPreference", "DayOfWeek"]
    - path: "src/app/features/meal-plan/services/meal-plan.service.ts"
      provides: "Service with CRUD for plans + assignments + preferences"
      exports: ["MealPlanService"]
  key_links:
    - from: "src/app/features/meal-plan/services/meal-plan.service.ts"
      to: "src/app/core/services/supabase.service.ts"
      via: "inject(SupabaseService)"
      pattern: "inject\\(SupabaseService\\)"
    - from: "src/app/features/meal-plan/services/meal-plan.service.ts"
      to: "src/app/features/meal-plan/models/meal-plan.model.ts"
      via: "import types"
      pattern: "import.*from.*meal-plan\\.model"
    - from: "supabase/migrations/003_meal_plans.sql"
      to: "supabase/migrations/002_dishes.sql"
      via: "foreign key reference to dishes table"
      pattern: "REFERENCES public\\.dishes"
user_setup:
  - service: supabase
    why: "New database migration must be run"
    dashboard_config:
      - task: "Run 003_meal_plans.sql migration"
        location: "Supabase Dashboard -> SQL Editor -> paste contents of 003_meal_plans.sql -> Run"
---

<objective>
Create the database schema and service layer for weekly meal plans, meal assignments, and category preferences.

Purpose: Establish the data foundation that both the calendar UI (Plan 02) and generation algorithm (Plan 03) depend on. Following the proven Phase 2 pattern of data-first, UI-second.

Output: Three database tables with RLS, TypeScript models, and MealPlanService with full CRUD operations.
</objective>

<execution_context>
@C:/Users/simon/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/simon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-meal-planning/03-CONTEXT.md
@.planning/phases/03-meal-planning/03-RESEARCH.md
@.planning/phases/02-dish-management/02-01-SUMMARY.md
@supabase/migrations/002_dishes.sql
@src/app/features/dishes/models/dish.model.ts
@src/app/features/dishes/services/dish.service.ts
@src/app/core/services/supabase.service.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create meal planning database migration with RLS policies</name>
  <files>supabase/migrations/003_meal_plans.sql</files>
  <action>
Create migration file following the exact pattern from 002_dishes.sql. Create three tables:

**Table 1: `public.weekly_plans`**
- `id` UUID DEFAULT gen_random_uuid() PRIMARY KEY
- `user_id` UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- `week_start` DATE NOT NULL (Monday of the week, stored as YYYY-MM-DD)
- `created_at` TIMESTAMPTZ DEFAULT NOW()
- `updated_at` TIMESTAMPTZ DEFAULT NOW()
- UNIQUE constraint on (user_id, week_start) to prevent duplicate plans per week per user

**Table 2: `public.meal_assignments`**
- `id` UUID DEFAULT gen_random_uuid() PRIMARY KEY
- `weekly_plan_id` UUID NOT NULL REFERENCES public.weekly_plans(id) ON DELETE CASCADE
- `day_of_week` SMALLINT NOT NULL CHECK (day_of_week BETWEEN 0 AND 6) -- 0=Monday, 6=Sunday
- `dish_id` UUID NOT NULL REFERENCES public.dishes(id) ON DELETE CASCADE
- `created_at` TIMESTAMPTZ DEFAULT NOW()
- `updated_at` TIMESTAMPTZ DEFAULT NOW()
- UNIQUE constraint on (weekly_plan_id, day_of_week) to enforce one dish per day per plan

**Table 3: `public.category_preferences`**
- `id` UUID DEFAULT gen_random_uuid() PRIMARY KEY
- `user_id` UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE
- `category` TEXT NOT NULL CHECK (category IN ('Fisch', 'Fleisch', 'Vegetarisch'))
- `count` SMALLINT NOT NULL DEFAULT 0 CHECK (count >= 0 AND count <= 7)
- `created_at` TIMESTAMPTZ DEFAULT NOW()
- `updated_at` TIMESTAMPTZ DEFAULT NOW()
- UNIQUE constraint on (user_id, category) to ensure one preference per category per user

**RLS Policies (for all three tables):**
- Enable RLS on each table
- SELECT/INSERT/UPDATE/DELETE policies using `(SELECT auth.uid())` wrapper pattern (per CVE-2025-48757 optimization)
- For meal_assignments: RLS through weekly_plans ownership (use subquery: `EXISTS (SELECT 1 FROM public.weekly_plans WHERE id = meal_assignments.weekly_plan_id AND user_id = (SELECT auth.uid()))`)

**Indexes:**
- `idx_weekly_plans_user_week` on weekly_plans(user_id, week_start) -- primary lookup
- `idx_meal_assignments_plan` on meal_assignments(weekly_plan_id) -- join performance
- `idx_meal_assignments_dish` on meal_assignments(dish_id) -- for repeat avoidance queries
- `idx_category_preferences_user` on category_preferences(user_id) -- preferences lookup

**Triggers:**
- Reuse `public.update_updated_at()` function from 001_profiles.sql for all three tables

Note: Use DATE type for week_start (not TIMESTAMPTZ) to avoid timezone ambiguity. The application sends ISO date strings like '2026-02-16'.
  </action>
  <verify>
Verify file exists and contains:
- Three CREATE TABLE statements (weekly_plans, meal_assignments, category_preferences)
- RLS enabled on all three tables (3x ALTER TABLE ... ENABLE ROW LEVEL SECURITY)
- `(SELECT auth.uid())` pattern used in all policies (not bare `auth.uid()`)
- UNIQUE constraints on (user_id, week_start), (weekly_plan_id, day_of_week), (user_id, category)
- Foreign key to public.dishes in meal_assignments
- CHECK constraints on day_of_week and category
- All indexes created
- All triggers created reusing update_updated_at()
  </verify>
  <done>Migration SQL file exists with three tables, RLS policies, indexes, and triggers following the established 002_dishes.sql pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Create meal plan models and MealPlanService with CRUD operations</name>
  <files>
    src/app/features/meal-plan/models/meal-plan.model.ts
    src/app/features/meal-plan/services/meal-plan.service.ts
  </files>
  <action>
**Model file (`meal-plan.model.ts`):**

Define and export these types:

```typescript
export type DayOfWeek = 0 | 1 | 2 | 3 | 4 | 5 | 6; // 0=Monday, 6=Sunday

export const DAY_LABELS: Record<DayOfWeek, string> = {
  0: 'Montag', 1: 'Dienstag', 2: 'Mittwoch', 3: 'Donnerstag',
  4: 'Freitag', 5: 'Samstag', 6: 'Sonntag'
};

export interface WeeklyPlan {
  id: string;
  user_id: string;
  week_start: string; // ISO date 'YYYY-MM-DD' (always a Monday)
  created_at: string;
  updated_at: string;
}

export interface MealAssignment {
  id: string;
  weekly_plan_id: string;
  day_of_week: DayOfWeek;
  dish_id: string;
  created_at: string;
  updated_at: string;
  dish?: Dish; // Joined from dishes table
}

export interface CategoryPreference {
  id: string;
  user_id: string;
  category: DishCategory;
  count: number;
  created_at: string;
  updated_at: string;
}

export interface WeeklyPlanWithAssignments {
  plan: WeeklyPlan;
  assignments: Map<DayOfWeek, MealAssignment>;
}

export const DEFAULT_CATEGORY_PREFERENCES: Record<DishCategory, number> = {
  Fleisch: 2,
  Vegetarisch: 2,
  Fisch: 1
}; // Total 5, leaving 2 days for "any" category
```

Import Dish and DishCategory from the existing dish model.

**Service file (`meal-plan.service.ts`):**

Create injectable service following the DishService pattern (inject SupabaseService, throw on error, no try/catch). Methods:

1. `getOrCreateWeeklyPlan(weekStart: string): Promise<WeeklyPlan>` -- Upsert: try to find existing plan for week_start, create if not found. Use user_id from auth.
2. `getAssignmentsForWeek(weekStart: string): Promise<MealAssignment[]>` -- Load all assignments for a week with dish data joined (select `*, dish:dishes(*)`). Return empty array if no plan exists.
3. `assignDish(weeklyPlanId: string, dayOfWeek: DayOfWeek, dishId: string): Promise<MealAssignment>` -- Upsert a meal assignment (use `.upsert()` with onConflict on weekly_plan_id + day_of_week).
4. `removeDish(assignmentId: string): Promise<void>` -- Delete a meal assignment.
5. `getRecentDishIds(currentWeekStart: string, weeksBack: number): Promise<Set<string>>` -- Query meal_assignments from the last N weeks (excluding current week) to get dish IDs used recently. Join through weekly_plans to filter by user and date range.
6. `getCategoryPreferences(): Promise<Record<DishCategory, number>>` -- Load user's category preferences. Return DEFAULT_CATEGORY_PREFERENCES if none saved.
7. `saveCategoryPreferences(prefs: Record<DishCategory, number>): Promise<void>` -- Upsert all three category preference rows for the user.
8. `clearWeekAssignments(weeklyPlanId: string): Promise<void>` -- Delete all meal_assignments for a plan (used before regeneration).

Helper function (can be exported from model file or service):
- `getWeekStart(date: Date): string` -- Calculate Monday of the week for a given date, return as ISO date string 'YYYY-MM-DD'. Use native Date API (no date-fns needed for this simple calculation).
- `getWeekDates(weekStart: string): string[]` -- Return array of 7 date strings (Mon-Sun) for display in the calendar.
- `formatDateGerman(dateStr: string): string` -- Format a date string to German format for day labels (e.g., "17. Feb.").
  </action>
  <verify>
Run `npx ng build` to verify TypeScript compilation succeeds. Then verify:
- meal-plan.model.ts exports WeeklyPlan, MealAssignment, CategoryPreference, DayOfWeek, DAY_LABELS, DEFAULT_CATEGORY_PREFERENCES, WeeklyPlanWithAssignments
- meal-plan.service.ts exports MealPlanService
- MealPlanService uses inject(SupabaseService)
- All 8 methods present: getOrCreateWeeklyPlan, getAssignmentsForWeek, assignDish, removeDish, getRecentDishIds, getCategoryPreferences, saveCategoryPreferences, clearWeekAssignments
- Helper functions getWeekStart, getWeekDates, formatDateGerman exist
  </verify>
  <done>TypeScript models and service compile without errors. MealPlanService provides all CRUD operations needed by the calendar UI (Plan 02) and generation algorithm (Plan 03).</done>
</task>

</tasks>

<verification>
1. Migration file `003_meal_plans.sql` exists with three tables, RLS, indexes, triggers
2. Model file exports all required types and constants
3. Service file exports MealPlanService with all 8 CRUD methods
4. `npx ng build` succeeds with zero errors
5. Service follows established pattern: inject(SupabaseService), throw on error
</verification>

<success_criteria>
- Three database tables (weekly_plans, meal_assignments, category_preferences) defined with proper constraints, RLS, and indexes
- TypeScript interfaces match database schema exactly
- MealPlanService provides complete CRUD for plans, assignments, and preferences
- Helper functions handle ISO week boundary calculations correctly
- Build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-meal-planning/03-01-SUMMARY.md`
</output>
