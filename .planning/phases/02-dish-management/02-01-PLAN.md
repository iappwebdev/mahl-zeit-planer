---
phase: 02-dish-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/migrations/002_dishes.sql
  - src/app/features/dishes/models/dish.model.ts
  - src/app/features/dishes/services/dish.service.ts
autonomous: true

must_haves:
  truths:
    - "Dishes table exists with RLS policies enforcing user isolation"
    - "DishService can create, read, update, and delete dishes via Supabase"
    - "DishService can toggle favorite status on a dish"
    - "Dish model has typed fields for id, user_id, name, category, is_favorite"
  artifacts:
    - path: "supabase/migrations/002_dishes.sql"
      provides: "Dishes table with RLS, indexes, and category CHECK constraint"
      contains: "CREATE TABLE public.dishes"
    - path: "src/app/features/dishes/models/dish.model.ts"
      provides: "TypeScript Dish interface"
      exports: ["Dish", "DishCategory"]
    - path: "src/app/features/dishes/services/dish.service.ts"
      provides: "CRUD operations for dishes via Supabase"
      exports: ["DishService"]
  key_links:
    - from: "src/app/features/dishes/services/dish.service.ts"
      to: "src/app/core/services/supabase.service.ts"
      via: "inject(SupabaseService) and this.supabase.client.from('dishes')"
      pattern: "inject\\(SupabaseService\\)"
    - from: "src/app/features/dishes/services/dish.service.ts"
      to: "src/app/features/dishes/models/dish.model.ts"
      via: "import { Dish } from '../models/dish.model'"
      pattern: "import.*Dish.*from.*dish\\.model"
---

<objective>
Create the dishes database table with Row Level Security and build the Angular DishService with full CRUD operations and typed Dish model.

Purpose: Establishes the data foundation for all dish management features. Without the table and service, no UI can persist or retrieve dishes.
Output: SQL migration file, TypeScript Dish interface, DishService with getAll/create/update/delete/toggleFavorite methods.
</objective>

<execution_context>
@C:/Users/simon/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/simon/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 1 established these patterns — follow them:
@src/app/core/services/supabase.service.ts
@supabase/migrations/001_profiles.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create dishes database migration with RLS policies</name>
  <files>supabase/migrations/002_dishes.sql</files>
  <action>
Create the dishes table migration following the EXACT pattern from `001_profiles.sql`.

**Table definition:**
```sql
CREATE TABLE public.dishes (
  id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  category TEXT NOT NULL CHECK (category IN ('Fisch', 'Fleisch', 'Vegetarisch')),
  is_favorite BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

Use TEXT with CHECK constraint for category (NOT PostgreSQL ENUM — per research decision, easier to modify without migrations).

**RLS policies (4 total):** Enable RLS immediately. Create SELECT, INSERT, UPDATE, DELETE policies. ALL must use the `(SELECT auth.uid())` wrapper pattern (per Phase 1 decision — 94-99% performance gain). Target `authenticated` role. Match `user_id` column.

**Indexes (3):**
- `idx_dishes_user_id` on `user_id` (RLS query performance)
- `idx_dishes_category` on `category` (filter queries)
- `idx_dishes_favorite` on `is_favorite` (sort queries)

**Trigger:** Reuse the existing `public.update_updated_at()` function (already created in 001_profiles.sql) for auto-updating `updated_at`. Create trigger `dishes_updated_at` on dishes table.

Include clear section headers with comments (matching 001_profiles.sql style).
  </action>
  <verify>
Verify the SQL file:
1. File exists at `supabase/migrations/002_dishes.sql`
2. Contains `ENABLE ROW LEVEL SECURITY`
3. Contains `(SELECT auth.uid())` in all 4 policies (grep for pattern)
4. Contains CHECK constraint for category values
5. Contains all 3 indexes
6. References `public.update_updated_at()` function (not redefines it)
  </verify>
  <done>
Migration SQL file exists with dishes table, 4 RLS policies using optimized auth pattern, CHECK constraint on category, 3 performance indexes, and updated_at trigger reusing existing function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Dish model and DishService with CRUD operations</name>
  <files>
    src/app/features/dishes/models/dish.model.ts
    src/app/features/dishes/services/dish.service.ts
  </files>
  <action>
**Dish model** (`src/app/features/dishes/models/dish.model.ts`):

Create and export:
- `DishCategory` type: `'Fisch' | 'Fleisch' | 'Vegetarisch'`
- `Dish` interface with fields:
  - `id: string` (UUID from Supabase)
  - `user_id: string`
  - `name: string`
  - `category: DishCategory`
  - `is_favorite: boolean`
  - `created_at: string` (ISO timestamp from Supabase)
  - `updated_at: string`
- `CreateDishPayload` type: `Pick<Dish, 'name' | 'category'>` (only fields user provides)

**DishService** (`src/app/features/dishes/services/dish.service.ts`):

Injectable service (`providedIn: 'root'`). Use `inject(SupabaseService)` to get the client (following existing pattern in codebase).

Methods:

1. `async getAll(): Promise<Dish[]>` — Select all from `dishes`, ordered by `is_favorite DESC, name ASC`. Return `data || []`.

2. `async create(payload: CreateDishPayload): Promise<Dish>` — Get current user via `this.supabase.client.auth.getUser()`, insert with `user_id: user.id`, `is_favorite: false`, call `.select().single()` to return created dish.

3. `async update(id: string, changes: Partial<Pick<Dish, 'name' | 'category'>>): Promise<Dish>` — Update dish by id, call `.select().single()` to return updated dish. RLS ensures user can only update own dishes.

4. `async delete(id: string): Promise<void>` — Delete dish by id. RLS ensures user can only delete own dishes.

5. `async toggleFavorite(id: string, isFavorite: boolean): Promise<Dish>` — Update `is_favorite` field, return updated dish via `.select().single()`.

All methods throw on error (let the component handle error display). Do NOT add try/catch in the service — errors bubble up to callers.

Use `private supabase = inject(SupabaseService)` pattern (not constructor injection).
  </action>
  <verify>
1. `src/app/features/dishes/models/dish.model.ts` exists with Dish, DishCategory, CreateDishPayload exports
2. `src/app/features/dishes/services/dish.service.ts` exists with DishService class
3. DishService has all 5 methods: getAll, create, update, delete, toggleFavorite
4. DishService uses `inject(SupabaseService)` (grep for pattern)
5. DishService imports Dish from the model file (grep for import)
6. Run `npx ng build --configuration=development` to verify TypeScript compiles without errors
  </verify>
  <done>
Dish model defines typed interface with DishCategory union type. DishService provides getAll, create, update, delete, and toggleFavorite methods using Supabase client with proper user_id handling and error propagation.
  </done>
</task>

</tasks>

<verification>
1. Migration SQL contains correct table schema with CHECK constraint
2. RLS policies use optimized (SELECT auth.uid()) pattern
3. TypeScript compiles: `npx ng build --configuration=development` passes
4. DishService correctly imports SupabaseService and Dish model
5. No circular dependencies introduced
</verification>

<success_criteria>
- dishes table migration ready to execute in Supabase SQL Editor
- Dish interface and DishCategory type exported and usable
- DishService injectable and provides full CRUD + favorite toggle
- Angular build compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-dish-management/02-01-SUMMARY.md`
</output>
